# PID-калибровки с автосохранением
[gcode_macro PID_TUNE_THERMAL_BASE]
description: PID bed+hotend with clear "Done" message (optionally SAVE_CONFIG)
gcode:
  {% set bed = params.BED|default(60)|float %}
  {% set hot = params.HOTEND|default(200)|float %}
  {% set fan = params.FAN|default(0)|int %}          # 0..255 (M106 S...)
  {% set autosave = params.AUTOSAVE|default(0)|int %} # 0/1

  RESPOND PREFIX="PID" MSG="Start thermal base: BED={bed}, HOTEND={hot}, FAN={fan}, AUTOSAVE={autosave}"
  SET_DISPLAY_TEXT MSG="PID tune: bed {bed}"

  # Part cooling fan (optional) - M106/M107 are standard in Klipper G-codes :contentReference[oaicite:2]{index=2}
  {% if fan <= 0 %}
    M107
  {% else %}
    M106 S{fan}
  {% endif %}

  # Bed PID tune
  RESPOND PREFIX="PID" MSG="Tuning bed PID at {bed}C..."
  PID_CALIBRATE HEATER=heater_bed TARGET={bed}

  # Hotend PID tune
  SET_DISPLAY_TEXT MSG="PID tune: hotend {hot}"
  RESPOND PREFIX="PID" MSG="Tuning hotend PID at {hot}C..."
  PID_CALIBRATE HEATER=extruder TARGET={hot}

  # Done (before any save/restart)
  SET_DISPLAY_TEXT MSG="PID tune done"
  RESPOND PREFIX="PID" MSG="Done. To store results run: SAVE_CONFIG"

  {% if autosave == 1 %}
    RESPOND PREFIX="PID" MSG="Autosave in 2s..."
    G4 P2000
    SAVE_CONFIG
  {% endif %}

# Калибровка оси Z
[gcode_macro TUNE_Z]
description: Thermally-stable Z tune: Z_TILT + BED_MESH + CARTOGRAPHER_TOUCH (+ optional SAVE_CONFIG)
gcode:
  {% set bed = params.BED|default(60)|float %}
  {% set noz_req = params.NOZZLE|default(150)|float %}
  {% set tol = params.TOL|default(0.5)|float %}
  {% set soak = params.SOAK|default(60)|int %}          # секунд выдержки после попадания в допуск
  {% set profile = params.PROFILE|default("z_tune") %}
  {% set do_save = params.SAVE|default(1)|int %}

  # Cartographer Touch: сопло не горячее 150C
  {% set noz = noz_req %}
  {% if noz > 150 %}
    {% set noz = 150 %}
  {% endif %}

  SAVE_GCODE_STATE NAME=TUNE_Z_STATE
  SET_DISPLAY_TEXT MSG="TUNE_Z: heating bed={bed}C noz={noz}C"

  # --- Heat (non-blocking set) ---
  M140 S{bed}
  M104 S{noz}

  # --- Wait until temps are within tolerance window ---
  TEMPERATURE_WAIT SENSOR=heater_bed MINIMUM={bed - tol} MAXIMUM={bed + tol}
  TEMPERATURE_WAIT SENSOR=extruder   MINIMUM={noz - tol} MAXIMUM={noz + tol}

  # --- Optional soak time for thermal stabilization ---
  {% if soak > 0 %}
    G4 P{soak * 1000}
  {% endif %}

  # --- Ensure homed (required for Z_TILT / mesh / touch) ---
  {% if "xyz" not in printer.toolhead.homed_axes|lower %}
    SET_DISPLAY_TEXT MSG="TUNE_Z: homing..."
    G28
  {% endif %}

  # --- Z tilt ---
  SET_DISPLAY_TEXT MSG="TUNE_Z: Z_TILT..."
  Z_TILT_ADJUST

  # --- Bed mesh into named profile ---
  SET_DISPLAY_TEXT MSG="TUNE_Z: bed mesh -> {profile}"
  BED_MESH_CLEAR
  BED_MESH_CALIBRATE PROFILE={profile}

  # --- Cartographer Touch (after mesh, nozzle <=150C) ---
  SET_DISPLAY_TEXT MSG="TUNE_Z: Cartographer touch..."
  TEMPERATURE_WAIT SENSOR=extruder MAXIMUM=150
  CARTOGRAPHER_TOUCH

  # --- Persist results (mesh profile) ---
  {% if do_save == 1 %}
    SET_DISPLAY_TEXT MSG="TUNE_Z: SAVE_CONFIG (restart)"
    SAVE_CONFIG
  {% else %}
    SET_DISPLAY_TEXT MSG="TUNE_Z: done (no save)"
    RESTORE_GCODE_STATE NAME=TUNE_Z_STATE MOVE=0
  {% endif %}

# Z backlash
[gcode_macro TUNE_Z_BL_EST]
description: Cartographer Z backlash estimation helper (MODE=REF or MODE=5POINTS)
variable_iterations: 20
variable_delta: 0.20
variable_margin: 10.0
variable_safe_z: 15.0
gcode:
  {% set mode = params.MODE|default("REF")|string|upper %}
  {% set it = params.ITER|default(printer["gcode_macro TUNE_Z_BL_EST"].iterations)|int %}
  {% set dl = params.DELTA|default(printer["gcode_macro TUNE_Z_BL_EST"].delta)|float %}
  {% set mg = params.MARGIN|default(printer["gcode_macro TUNE_Z_BL_EST"].margin)|float %}
  {% set zsafe = params.SAFE_Z|default(printer["gcode_macro TUNE_Z_BL_EST"].safe_z)|float %}
  {% set do_cal = params.CALIBRATE|default(1)|int %}

  {% if mode not in ["REF","REFERENCE","5POINTS","CORNERS","DIAG"] %}
    RESPOND TYPE=error MSG="TUNE_Z_BL_EST: Unknown MODE={mode}. Use MODE=REF or MODE=5POINTS"
  {% else %}

    # --- Home first ---
    {% if "x" not in printer.toolhead.homed_axes|lower or "y" not in printer.toolhead.homed_axes|lower %}
      RESPOND MSG="TUNE_Z_BL_EST: Homing XY..."
      G28 X Y
    {% endif %}
    {% if "z" not in printer.toolhead.homed_axes|lower %}
      RESPOND MSG="TUNE_Z_BL_EST: Homing Z..."
      G28 Z
    {% endif %}

    {% set cfg = printer.configfile.settings %}

    # --- HARD XY limits from steppers (authoritative) ---
    {% set x_min = cfg.stepper_x.position_min|default(0)|float %}
    {% set x_max = cfg.stepper_x.position_max|float %}
    {% set y_min = cfg.stepper_y.position_min|default(0)|float %}
    {% set y_max = cfg.stepper_y.position_max|float %}

    # --- mesh bounds (prefer bed_mesh area); fallback to full travel ---
    {% set mx0 = x_min %}{% set my0 = y_min %}
    {% set mx1 = x_max %}{% set my1 = y_max %}

    {% if cfg.bed_mesh is defined and cfg.bed_mesh.mesh_min is defined and cfg.bed_mesh.mesh_max is defined %}
      {% set mmn = cfg.bed_mesh.mesh_min %}
      {% set mmx = cfg.bed_mesh.mesh_max %}

      {% if mmn is string %}
        {% set a = mmn.replace(' ', '').split(',') %}
        {% if a|length >= 2 %}{% set mx0 = a[0]|float %}{% set my0 = a[1]|float %}{% endif %}
      {% else %}
        {% set mx0 = mmn[0]|float %}{% set my0 = mmn[1]|float %}
      {% endif %}

      {% if mmx is string %}
        {% set b = mmx.replace(' ', '').split(',') %}
        {% if b|length >= 2 %}{% set mx1 = b[0]|float %}{% set my1 = b[1]|float %}{% endif %}
      {% else %}
        {% set mx1 = mmx[0]|float %}{% set my1 = mmx[1]|float %}
      {% endif %}
    {% endif %}

    # --- reference point: zero_reference_position, else center of mesh ---
    {% set x_ref = (mx0 + mx1) / 2.0 %}
    {% set y_ref = (my0 + my1) / 2.0 %}

    {% if cfg.bed_mesh is defined and cfg.bed_mesh.zero_reference_position is defined %}
      {% set zrp = cfg.bed_mesh.zero_reference_position %}
      {% if zrp is string %}
        {% set p = zrp.replace(' ', '').split(',') %}
        {% if p|length >= 2 %}{% set x_ref = p[0]|float %}{% set y_ref = p[1]|float %}{% endif %}
      {% else %}
        {% set x_ref = zrp[0]|float %}{% set y_ref = zrp[1]|float %}
      {% endif %}
    {% endif %}

    # --- bounds with margin, clipped to HARD limits ---
    {% set x_lo = mx0 + mg %}{% set x_hi = mx1 - mg %}
    {% set y_lo = my0 + mg %}{% set y_hi = my1 - mg %}

    {% if x_lo < x_min %}{% set x_lo = x_min %}{% endif %}
    {% if x_hi > x_max %}{% set x_hi = x_max %}{% endif %}
    {% if y_lo < y_min %}{% set y_lo = y_min %}{% endif %}
    {% if y_hi > y_max %}{% set y_hi = y_max %}{% endif %}

    {% if x_ref < x_lo %}{% set x_ref = x_lo %}{% endif %}
    {% if x_ref > x_hi %}{% set x_ref = x_hi %}{% endif %}
    {% if y_ref < y_lo %}{% set y_ref = y_lo %}{% endif %}
    {% if y_ref > y_hi %}{% set y_ref = y_hi %}{% endif %}

    # --- Safe Z ---
    {% set z_max2 = printer.toolhead.axis_maximum.z|float %}
    {% set z_move = zsafe %}
    {% if z_move > (z_max2 - 1.0) %}{% set z_move = (z_max2 - 1.0) %}{% endif %}
    G90
    G1 Z{z_move|round(2)} F3000

    # Debug (чтобы сразу видеть, что посчиталось)
    RESPOND MSG="TUNE_Z_BL_EST: X[{x_min},{x_max}] Y[{y_min},{y_max}] mesh=({mx0},{my0})-({mx1},{my1}) ref=({x_ref},{y_ref}) margin={mg}"

    RESPOND MSG="TUNE_Z_BL_EST: mode={mode}, ITER={it}, DELTA={dl}. Watch console for Cartographer 'delta' output."

    # --- REF ---
    SET_DISPLAY_TEXT MSG="Z BL: REF"
    G1 X{x_ref|round(2)} Y{y_ref|round(2)} F9000
    G4 P300
    {% if do_cal == 1 %}
      CARTOGRAPHER_ESTIMATE_BACKLASH ITERATIONS={it} DELTA={dl} CALIBRATE=1
    {% else %}
      CARTOGRAPHER_ESTIMATE_BACKLASH ITERATIONS={it} DELTA={dl}
    {% endif %}
    G4 P300

    {% if mode in ["5POINTS","CORNERS","DIAG"] %}
      # FL
      SET_DISPLAY_TEXT MSG="Z BL: FL"
      G1 X{x_lo|round(2)} Y{y_lo|round(2)} F9000
      G4 P200
      CARTOGRAPHER_ESTIMATE_BACKLASH ITERATIONS={it} DELTA={dl}
      G4 P200
      # FR
      SET_DISPLAY_TEXT MSG="Z BL: FR"
      G1 X{x_hi|round(2)} Y{y_lo|round(2)} F9000
      G4 P200
      CARTOGRAPHER_ESTIMATE_BACKLASH ITERATIONS={it} DELTA={dl}
      G4 P200
      # RR
      SET_DISPLAY_TEXT MSG="Z BL: RR"
      G1 X{x_hi|round(2)} Y{y_hi|round(2)} F9000
      G4 P200
      CARTOGRAPHER_ESTIMATE_BACKLASH ITERATIONS={it} DELTA={dl}
      G4 P200
      # RL
      SET_DISPLAY_TEXT MSG="Z BL: RL"
      G1 X{x_lo|round(2)} Y{y_hi|round(2)} F9000
      G4 P200
      CARTOGRAPHER_ESTIMATE_BACKLASH ITERATIONS={it} DELTA={dl}
      G4 P200
    {% endif %}

    SET_DISPLAY_TEXT MSG="Z BL done"
    RESPOND MSG="TUNE_Z_BL_EST: Done. Copy Cartographer-reported 'delta' into [scanner] backlash_comp."
  {% endif %}

# Калибровка SHAKETUNE
[gcode_macro SHAKETUNE_CHECK]
description: Shake&Tune: (optional) AXES_MAP + (CoreXY/CoreXZ) COMPARE_BELTS_RESPONSES + AXES_SHAPER_CALIBRATION + (optional) CREATE_VIBRATIONS_PROFILE

# ---- defaults (can be overridden in the command) ----
variable_freq_start: 5.0
variable_freq_end: 133.33
variable_hz_per_sec: 1.0

variable_keep_n_results: 5
variable_keep_csv: 1            # 1=keep CSV, 0=delete CSV (если ваша версия поддерживает)

variable_do_axesmap: 0          # 1=run AXES_MAP_CALIBRATION
variable_do_belts: 1            # 1=run COMPARE_BELTS_RESPONSES (auto-disabled if not CoreXY/CoreXZ)
variable_do_vibr: 0             # 1=run CREATE_VIBRATIONS_PROFILE (last step)

# belt compare sometimes requires explicit Z height depending on resonance_tester test_point
variable_z_height: 50

gcode:
  {% set kin = printer.configfile.settings.printer.kinematics|default("")|lower %}
  {% set is_corexy = (kin == "corexy") or (kin == "corexz") %}

  {% set do_axesmap = params.AXESMAP|default(printer["gcode_macro SHAKETUNE_CHECK"].do_axesmap)|int %}
  {% set do_belts   = params.BELTS|default(printer["gcode_macro SHAKETUNE_CHECK"].do_belts)|int %}
  {% set do_vibr    = params.VIBR|default(printer["gcode_macro SHAKETUNE_CHECK"].do_vibr)|int %}

  {% if not is_corexy %}
    {% set do_belts = 0 %}
  {% endif %}

  {% set f0 = params.FREQ_START|default(printer["gcode_macro SHAKETUNE_CHECK"].freq_start)|float %}
  {% set f1 = params.FREQ_END|default(printer["gcode_macro SHAKETUNE_CHECK"].freq_end)|float %}
  {% set hz = params.HZ_PER_SEC|default(printer["gcode_macro SHAKETUNE_CHECK"].hz_per_sec)|float %}

  {% set keep = params.KEEP_N_RESULTS|default(printer["gcode_macro SHAKETUNE_CHECK"].keep_n_results)|int %}
  {% set keep_csv_i = params.KEEP_CSV|default(printer["gcode_macro SHAKETUNE_CHECK"].keep_csv)|int %}
  {% set keep_csv = (keep_csv_i != 0) %}

  {% set z_h = params.Z_HEIGHT|default(printer["gcode_macro SHAKETUNE_CHECK"].z_height)|int %}

  # Optional: explicit accelerometer selection (supported in newer Shake&Tune)
  # Example: ACCEL_CHIP="'adxl345 scanner'"
  {% set accel_chip = params.ACCEL_CHIP|default("") %}

  SET_DISPLAY_TEXT MSG="Shake&Tune: start"
  M400

  # Ensure homed
  {% set homed = printer.toolhead.homed_axes|lower %}
  {% if ("x" not in homed) or ("y" not in homed) or ("z" not in homed) %}
    G28
  {% endif %}

  {% if do_axesmap %}
    SET_DISPLAY_TEXT MSG="Shake&Tune: axes map"
    {% if accel_chip != "" %}
      AXES_MAP_CALIBRATION ACCEL_CHIP={accel_chip}
    {% else %}
      AXES_MAP_CALIBRATION
    {% endif %}
  {% endif %}

  {% if do_belts %}
    SET_DISPLAY_TEXT MSG="Shake&Tune: compare belts"
    # Docs show at least FREQ_START/FREQ_END/HZ_PER_SEC; Z_HEIGHT can be required in some configs
    {% if accel_chip != "" %}
      COMPARE_BELTS_RESPONSES FREQ_START={f0} FREQ_END={f1} HZ_PER_SEC={hz} Z_HEIGHT={z_h} ACCEL_CHIP={accel_chip}
    {% else %}
      COMPARE_BELTS_RESPONSES FREQ_START={f0} FREQ_END={f1} HZ_PER_SEC={hz} Z_HEIGHT={z_h}
    {% endif %}
  {% endif %}

  SET_DISPLAY_TEXT MSG="Shake&Tune: axes shaper"
  {% if accel_chip != "" %}
    AXES_SHAPER_CALIBRATION FREQ_START={f0} FREQ_END={f1} HZ_PER_SEC={hz} KEEP_N_RESULTS={keep} KEEP_CSV={keep_csv} ACCEL_CHIP={accel_chip}
  {% else %}
    AXES_SHAPER_CALIBRATION FREQ_START={f0} FREQ_END={f1} HZ_PER_SEC={hz} KEEP_N_RESULTS={keep} KEEP_CSV={keep_csv}
  {% endif %}

  {% if do_vibr %}
    SET_DISPLAY_TEXT MSG="Shake&Tune: vibrations profile"

    {% set size = params.SIZE|default(100)|int %}
    {% set z_hp = params.Z_HEIGHT_PROFILE|default(20)|int %}
    {% set vmax = params.MAX_SPEED|default(200)|int %}
    {% set inc  = params.SPEED_INCREMENT|default(2)|int %}
    {% set accel= params.ACCEL|default(3000)|int %}

    {% if accel_chip != "" %}
      CREATE_VIBRATIONS_PROFILE SIZE={size} Z_HEIGHT={z_hp} MAX_SPEED={vmax} SPEED_INCREMENT={inc} ACCEL={accel} ACCEL_CHIP={accel_chip}
    {% else %}
      CREATE_VIBRATIONS_PROFILE SIZE={size} Z_HEIGHT={z_hp} MAX_SPEED={vmax} SPEED_INCREMENT={inc} ACCEL={accel}
    {% endif %}
  {% endif %}

  SET_DISPLAY_TEXT MSG="Shake&Tune: done"

[pause_resume]

[gcode_macro _AXIS_TEST_STATE]
description: Internal storage for restoring velocity limits
variable_base_v: 0.0
variable_base_a: 0.0
variable_base_atd: 0.0
gcode:

[gcode_macro AXIS_SPEED_CALIB]
description: Sweep speed for one axis (X/Y/Z). Runs moves and pauses after each step.
gcode:
  {% set axis = (params.AXIS|default("X")|string|upper) %}
  {% set vstart = params.VSTART|default(50)|float %}     # mm/s
  {% set vend   = params.VEND|default(300)|float %}      # mm/s
  {% set vstep  = params.VSTEP|default(25)|float %}      # mm/s
  {% set accel  = params.ACCEL|default(3000)|float %}    # mm/s^2
  {% set cycles = params.CYCLES|default(20)|int %}
  {% set margin = params.MARGIN|default(20)|float %}
  {% set home   = params.HOME|default(1)|int %}
  {% set interactive = params.INTERACTIVE|default(1)|int %}
  {% set zmin = params.ZMIN|default(5)|float %}
  {% set zdist = params.ZDIST|default(20)|float %}

  {% if axis not in ["X","Y","Z"] %}
    {action_raise_error("AXIS must be X, Y, or Z")}
  {% endif %}

  SAVE_GCODE_STATE NAME=AXIS_SPEED_CALIB_STATE
  G90

  # Optionally home
  {% if home == 1 %}
    M118 Homing...
    G28
  {% else %}
    # Ensure requested axis is homed
    {% set ha = printer.toolhead.homed_axes|string|lower %}
    {% if axis|lower not in ha %}
      {action_raise_error("Axis not homed. Run with HOME=1 or home the axis first.")}
    {% endif %}
  {% endif %}

  # Store current limits to restore later
  SET_GCODE_VARIABLE MACRO=_AXIS_TEST_STATE VARIABLE=base_v VALUE={printer.toolhead.max_velocity}
  SET_GCODE_VARIABLE MACRO=_AXIS_TEST_STATE VARIABLE=base_a VALUE={printer.toolhead.max_accel}
  SET_GCODE_VARIABLE MACRO=_AXIS_TEST_STATE VARIABLE=base_atd VALUE={printer.toolhead.max_accel_to_decel}

  # Determine travel endpoints with margin
  {% if axis == "X" %}
    {% set amin = printer.toolhead.axis_minimum.x + margin %}
    {% set amax = printer.toolhead.axis_maximum.x - margin %}
    {% if amax <= amin %}
      {action_raise_error("X range too small with given MARGIN")}
    {% endif %}
    M118 Using X range: {amin:.2f} .. {amax:.2f}

  {% elif axis == "Y" %}
    {% set amin = printer.toolhead.axis_minimum.y + margin %}
    {% set amax = printer.toolhead.axis_maximum.y - margin %}
    {% if amax <= amin %}
      {action_raise_error("Y range too small with given MARGIN")}
    {% endif %}
    M118 Using Y range: {amin:.2f} .. {amax:.2f}

  {% else %}  # Z
    {% set z0 = printer.toolhead.axis_minimum.z + zmin %}
    {% set z1 = z0 + zdist %}
    {% set zmax = printer.toolhead.axis_maximum.z - margin %}
    {% if z1 > zmax %}
      {% set z1 = zmax %}
    {% endif %}
    {% if z1 <= z0 %}
      {action_raise_error("Z range too small (check ZMIN/ZDIST/MARGIN)")}
    {% endif %}
    M118 Using Z range: {z0:.2f} .. {z1:.2f}
  {% endif %}

  # Apply accel (velocity will be stepped)
  SET_VELOCITY_LIMIT ACCEL={accel} ACCEL_TO_DECEL={accel}

  M118 Starting AXIS_SPEED_CALIB axis={axis}, v={vstart}..{vend} step={vstep}, accel={accel}, cycles={cycles}

  {% set v = vstart %}
  {% for _ in range(1000000) %}
    {% if v > vend + 1e-6 %}
      {% break %}
    {% endif %}

    SET_VELOCITY_LIMIT VELOCITY={v}

    M118 ---- axis={axis} test speed={v:.1f} mm/s ----
    M400

    {% if axis == "X" %}
      {% for i in range(cycles) %}
        G0 X{amin:.3f} F{v*60:.0f}
        G0 X{amax:.3f} F{v*60:.0f}
      {% endfor %}
    {% elif axis == "Y" %}
      {% for i in range(cycles) %}
        G0 Y{amin:.3f} F{v*60:.0f}
        G0 Y{amax:.3f} F{v*60:.0f}
      {% endfor %}
    {% else %}
      {% for i in range(cycles) %}
        G0 Z{z0:.3f} F{v*60:.0f}
        G0 Z{z1:.3f} F{v*60:.0f}
      {% endfor %}
    {% endif %}

    M400
    M118 Completed speed={v:.1f}. If OK: RESUME. If issues: CANCEL_PRINT (or FIRMWARE_RESTART).
    {% if interactive == 1 %}
      PAUSE
    {% endif %}

    {% set v = v + vstep %}
  {% endfor %}

  # Restore original limits
  SET_VELOCITY_LIMIT VELOCITY={printer["gcode_macro _AXIS_TEST_STATE"].base_v} ACCEL={printer["gcode_macro _AXIS_TEST_STATE"].base_a} ACCEL_TO_DECEL={printer["gcode_macro _AXIS_TEST_STATE"].base_atd}
  RESTORE_GCODE_STATE NAME=AXIS_SPEED_CALIB_STATE
  M118 AXIS_SPEED_CALIB finished. Limits restored.

# Поиск макс. скоростей
[pause_resume]

[gcode_macro _AXIS_TEST_STATE]
description: Internal storage for restoring velocity limits
variable_base_v: 0.0
variable_base_a: 0.0
variable_base_atd: 0.0
gcode:


[gcode_macro AXIS_SPEED_CALIB]
description: Sweep speed for one axis (X/Y/Z). Runs moves and pauses after each step.
gcode:
  {% set axis = (params.AXIS|default("X")|string|upper) %}
  {% set vstart = params.VSTART|default(50)|float %}     # mm/s
  {% set vend   = params.VEND|default(300)|float %}      # mm/s
  {% set vstep  = params.VSTEP|default(25)|float %}      # mm/s
  {% set accel  = params.ACCEL|default(3000)|float %}    # mm/s^2
  {% set cycles = params.CYCLES|default(20)|int %}
  {% set margin = params.MARGIN|default(20)|float %}
  {% set home   = params.HOME|default(1)|int %}
  {% set interactive = params.INTERACTIVE|default(1)|int %}
  {% set zmin = params.ZMIN|default(5)|float %}
  {% set zdist = params.ZDIST|default(20)|float %}

  {% if axis not in ["X","Y","Z"] %}
    {action_raise_error("AXIS must be X, Y, or Z")}
  {% endif %}
  {% if vstep <= 0 %}
    {action_raise_error("VSTEP must be > 0")}
  {% endif %}
  {% if vend < vstart %}
    {action_raise_error("VEND must be >= VSTART")}
  {% endif %}
  {% if cycles < 1 %}
    {action_raise_error("CYCLES must be >= 1")}
  {% endif %}

  SAVE_GCODE_STATE NAME=AXIS_SPEED_CALIB_STATE
  G90

  {% if home == 1 %}
    M118 Homing...
    G28
  {% else %}
    {% set ha = printer.toolhead.homed_axes|string|lower %}
    {% if axis|lower not in ha %}
      {action_raise_error("Axis not homed. Run with HOME=1 or home the axis first.")}
    {% endif %}
  {% endif %}

  # Store current limits to restore later
  SET_GCODE_VARIABLE MACRO=_AXIS_TEST_STATE VARIABLE=base_v VALUE={printer.toolhead.max_velocity}
  SET_GCODE_VARIABLE MACRO=_AXIS_TEST_STATE VARIABLE=base_a VALUE={printer.toolhead.max_accel}
  SET_GCODE_VARIABLE MACRO=_AXIS_TEST_STATE VARIABLE=base_atd VALUE={printer.toolhead.max_accel_to_decel}

  # Determine travel endpoints with margin
  {% if axis == "X" %}
    {% set amin = printer.toolhead.axis_minimum.x + margin %}
    {% set amax = printer.toolhead.axis_maximum.x - margin %}
    {% if amax <= amin %}
      {action_raise_error("X range too small with given MARGIN")}
    {% endif %}
    M118 Using X range: {"%.2f"|format(amin)} .. {"%.2f"|format(amax)}

  {% elif axis == "Y" %}
    {% set amin = printer.toolhead.axis_minimum.y + margin %}
    {% set amax = printer.toolhead.axis_maximum.y - margin %}
    {% if amax <= amin %}
      {action_raise_error("Y range too small with given MARGIN")}
    {% endif %}
    M118 Using Y range: {"%.2f"|format(amin)} .. {"%.2f"|format(amax)}

  {% else %}  # Z
    {% set z0 = printer.toolhead.axis_minimum.z + zmin %}
    {% set z1 = z0 + zdist %}
    {% set zmax = printer.toolhead.axis_maximum.z - margin %}
    {% if z1 > zmax %}
      {% set z1 = zmax %}
    {% endif %}
    {% if z1 <= z0 %}
      {action_raise_error("Z range too small (check ZMIN/ZDIST/MARGIN)")}
    {% endif %}
    M118 Using Z range: {"%.2f"|format(z0)} .. {"%.2f"|format(z1)}
  {% endif %}

  # Apply accel (speed will be stepped)
  SET_VELOCITY_LIMIT ACCEL={accel} ACCEL_TO_DECEL={accel}

  # Build a fixed number of speed steps (Klipper Jinja has no {% break %})
  {% set raw_steps = ((vend - vstart) / vstep)|int %}
  {% set lastv = vstart + raw_steps * vstep %}
  {% if lastv < vend - 0.0001 %}
    {% set step_count = raw_steps + 2 %}   # include final VEND
  {% else %}
    {% set step_count = raw_steps + 1 %}
  {% endif %}

  M118 Starting AXIS_SPEED_CALIB axis={axis}, v={"%.1f"|format(vstart)}..{"%.1f"|format(vend)} step={"%.1f"|format(vstep)}, accel={"%.0f"|format(accel)}, cycles={cycles}

  {% for idx in range(step_count) %}
    {% if idx == step_count - 1 %}
      {% set v = vend %}
    {% else %}
      {% set v = vstart + idx * vstep %}
    {% endif %}

    {% set f = (v * 60)|int %}

    SET_VELOCITY_LIMIT VELOCITY={v}
    M118 ---- axis={axis} test speed={"%.1f"|format(v)} mm/s ----
    M400

    {% if axis == "X" %}
      {% for i in range(cycles) %}
        G0 X{amin} F{f}
        G0 X{amax} F{f}
      {% endfor %}
    {% elif axis == "Y" %}
      {% for i in range(cycles) %}
        G0 Y{amin} F{f}
        G0 Y{amax} F{f}
      {% endfor %}
    {% else %}
      {% for i in range(cycles) %}
        G0 Z{z0} F{f}
        G0 Z{z1} F{f}
      {% endfor %}
    {% endif %}

    M400
    M118 Completed speed={"%.1f"|format(v)}. If OK: RESUME. If issues: CANCEL_PRINT (or FIRMWARE_RESTART).
    {% if interactive == 1 %}
      PAUSE
    {% endif %}
  {% endfor %}

  # Restore original limits
  SET_VELOCITY_LIMIT VELOCITY={printer["gcode_macro _AXIS_TEST_STATE"].base_v} ACCEL={printer["gcode_macro _AXIS_TEST_STATE"].base_a} ACCEL_TO_DECEL={printer["gcode_macro _AXIS_TEST_STATE"].base_atd}
  RESTORE_GCODE_STATE NAME=AXIS_SPEED_CALIB_STATE
  M118 AXIS_SPEED_CALIB finished. Limits restored.


[gcode_macro AXIS_ACCEL_CALIB]
description: Sweep acceleration for one axis at fixed speed. Pauses after each step.
gcode:
  {% set axis = (params.AXIS|default("X")|string|upper) %}
  {% set v = params.V|default(200)|float %}               # mm/s (fixed)
  {% set astart = params.ASTART|default(1000)|float %}    # mm/s^2
  {% set aend   = params.AEND|default(10000)|float %}     # mm/s^2
  {% set astep  = params.ASTEP|default(1000)|float %}     # mm/s^2
  {% set cycles = params.CYCLES|default(20)|int %}
  {% set margin = params.MARGIN|default(20)|float %}
  {% set home   = params.HOME|default(1)|int %}
  {% set interactive = params.INTERACTIVE|default(1)|int %}
  {% set zmin = params.ZMIN|default(5)|float %}
  {% set zdist = params.ZDIST|default(20)|float %}

  {% if axis not in ["X","Y","Z"] %}
    {action_raise_error("AXIS must be X, Y, or Z")}
  {% endif %}
  {% if astep <= 0 %}
    {action_raise_error("ASTEP must be > 0")}
  {% endif %}
  {% if aend < astart %}
    {action_raise_error("AEND must be >= ASTART")}
  {% endif %}
  {% if cycles < 1 %}
    {action_raise_error("CYCLES must be >= 1")}
  {% endif %}

  SAVE_GCODE_STATE NAME=AXIS_ACCEL_CALIB_STATE
  G90

  {% if home == 1 %}
    M118 Homing...
    G28
  {% else %}
    {% set ha = printer.toolhead.homed_axes|string|lower %}
    {% if axis|lower not in ha %}
      {action_raise_error("Axis not homed. Run with HOME=1 or home the axis first.")}
    {% endif %}
  {% endif %}

  # Store current limits to restore later
  SET_GCODE_VARIABLE MACRO=_AXIS_TEST_STATE VARIABLE=base_v VALUE={printer.toolhead.max_velocity}
  SET_GCODE_VARIABLE MACRO=_AXIS_TEST_STATE VARIABLE=base_a VALUE={printer.toolhead.max_accel}
  SET_GCODE_VARIABLE MACRO=_AXIS_TEST_STATE VARIABLE=base_atd VALUE={printer.toolhead.max_accel_to_decel}

  # Determine travel endpoints with margin
  {% if axis == "X" %}
    {% set amin = printer.toolhead.axis_minimum.x + margin %}
    {% set amax = printer.toolhead.axis_maximum.x - margin %}
    {% if amax <= amin %}
      {action_raise_error("X range too small with given MARGIN")}
    {% endif %}
  {% elif axis == "Y" %}
    {% set amin = printer.toolhead.axis_minimum.y + margin %}
    {% set amax = printer.toolhead.axis_maximum.y - margin %}
    {% if amax <= amin %}
      {action_raise_error("Y range too small with given MARGIN")}
    {% endif %}
  {% else %}
    {% set z0 = printer.toolhead.axis_minimum.z + zmin %}
    {% set z1 = z0 + zdist %}
    {% set zmax = printer.toolhead.axis_maximum.z - margin %}
    {% if z1 > zmax %}
      {% set z1 = zmax %}
    {% endif %}
    {% if z1 <= z0 %}
      {action_raise_error("Z range too small (check ZMIN/ZDIST/MARGIN)")}
    {% endif %}
  {% endif %}

  # Fix speed; sweep accel
  SET_VELOCITY_LIMIT VELOCITY={v}

  {% set raw_steps = ((aend - astart) / astep)|int %}
  {% set lasta = astart + raw_steps * astep %}
  {% if lasta < aend - 0.0001 %}
    {% set step_count = raw_steps + 2 %}   # include final AEND
  {% else %}
    {% set step_count = raw_steps + 1 %}
  {% endif %}

  M118 Starting AXIS_ACCEL_CALIB axis={axis}, accel={"%.0f"|format(astart)}..{"%.0f"|format(aend)} step={"%.0f"|format(astep)} at v={"%.1f"|format(v)} mm/s, cycles={cycles}

  {% set f = (v * 60)|int %}

  {% for idx in range(step_count) %}
    {% if idx == step_count - 1 %}
      {% set a = aend %}
    {% else %}
      {% set a = astart + idx * astep %}
    {% endif %}

    SET_VELOCITY_LIMIT ACCEL={a} ACCEL_TO_DECEL={a}
    M118 ---- axis={axis} test accel={"%.0f"|format(a)} mm/s^2 @ v={"%.1f"|format(v)} ----
    M400

    {% if axis == "X" %}
      {% for i in range(cycles) %}
        G0 X{amin} F{f}
        G0 X{amax} F{f}
      {% endfor %}
    {% elif axis == "Y" %}
      {% for i in range(cycles) %}
        G0 Y{amin} F{f}
        G0 Y{amax} F{f}
      {% endfor %}
    {% else %}
      {% for i in range(cycles) %}
        G0 Z{z0} F{f}
        G0 Z{z1} F{f}
      {% endfor %}
    {% endif %}

    M400
    M118 Completed accel={"%.0f"|format(a)}. If OK: RESUME. If issues: CANCEL_PRINT (or FIRMWARE_RESTART).
    {% if interactive == 1 %}
      PAUSE
    {% endif %}
  {% endfor %}

  # Restore original limits
  SET_VELOCITY_LIMIT VELOCITY={printer["gcode_macro _AXIS_TEST_STATE"].base_v} ACCEL={printer["gcode_macro _AXIS_TEST_STATE"].base_a} ACCEL_TO_DECEL={printer["gcode_macro _AXIS_TEST_STATE"].base_atd}
  RESTORE_GCODE_STATE NAME=AXIS_ACCEL_CALIB_STATE
  M118 AXIS_ACCEL_CALIB finished. Limits restored.

